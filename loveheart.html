<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>love line with Mrs.Right</title>

<style type="text/css">
@font-face {
	font-family: digit;
	src: url('digital-7_mono.ttf') format("truetype");
}
	html,
	body {
		 height: 100%;
		 padding: 0;
		 margin: 0;
		 background: #000;
	 }
	 #pinkboard {
		 position: absolute;
		 width: 100%;
		 height: 100%;
	 }
	 #garden {
		 position: absolute;
		 width: 100%;
		 height: 100%;
		 left: 21.5%;
		 top: 22.5%;
	 }
</style>

<link href="css/default.css" type="text/css" rel="stylesheet">
<script type="text/javascript" src="js/jquery.js"></script>
<script type="text/javascript" src="js/garden.js"></script>
<script type="text/javascript" src="js/functions.js"></script>

</head>

<body>

<div id="mainDiv">
	<div id="content">
		
		<div id="loveHeart" style="position:relative">
			
			<canvas id="garden"></canvas>
			<canvas id="pinkboard"></canvas>
			<div id="words">
				<div id="messages">
					和宝贝贴贴...
					<div id="elapseClock"></div>
				</div>
				<div id="loveu">
					<br/>
					<div class="signature">To 小叶子</div>
				</div>

			</div>
		</div>
	</div>
</div>

<script type="text/javascript">
var offsetX = $("#loveHeart").width() / 2;
var offsetY = $("#loveHeart").height() / 2 - 55;
var together = new Date();

together.setFullYear(2022, 9, 31);//1.23；3.29
together.setHours(19);
together.setMinutes(0);
together.setSeconds(0);
together.setMilliseconds(0);

if (!document.createElement('canvas').getContext) {
	var msg = document.createElement("div");
	msg.id = "errorMsg";
	msg.innerHTML = "Your browser doesn't support HTML5!<br/>Recommend use Chrome 14+/IE 9+/Firefox 7+/Safari 4+";
	document.body.appendChild(msg);
	$("#code").css("display", "none")
	$("#copyright").css("position", "absolute");
	$("#copyright").css("bottom", "10px");
	document.execCommand("stop");
} else {
	setTimeout(function () {
		startHeartAnimation();
	}, 0);

	timeElapse(together);
	setInterval(function () {
		timeElapse(together);
	}, 1000);

	// adjustCodePosition();
	// $("#code").typewriter();
}
</script>
<script>
	/*
* Settings
*/
	 var settings = {
		 particles: {
			 length: 1000, // maximum amount of particles
			 duration: 3, // particle duration in sec
			 velocity: 50, // particle velocity in pixels/sec
			 effect: -0.25, // play with this for a nice effect
			 size: 25, // particle size in pixels
		 },
	 };
	 /*
	 * RequestAnimationFrame polyfill by Erik Möller
	 */
	 (function () {
		var b = 0;
		var c = ["ms", "moz", "webkit", "o"];
		for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) {
			window.requestAnimationFrame = window[c[a] + "RequestAnimationFrame"];
			window.cancelAnimationFrame = window[c[a] + "CancelAnimationFrame"] || window[c[a] +
				"CancelRequestAnimationFrame"]
		}
		if (!window.requestAnimationFrame) {
			window.requestAnimationFrame = function (h, e) {
				var d = new Date().getTime();
				var f = Math.max(0, 16 - (d - b));
				var g = window.setTimeout(function () {
					h(d + f)
				}, f);
				b = d + f;
				return g
			}
		}
		if (!window.cancelAnimationFrame) {
			window.cancelAnimationFrame = function (d) {
				clearTimeout(d)
			}
		}
	}());
	 /*
	 * Point class
	 */
	 var Point = (function () {
		 function Point(x, y) {
			 this.x = (typeof x !== 'undefined') ? x*1.2 : 0;
			 this.y = (typeof y !== 'undefined') ? y*1.2 : 0;
		 }
		 Point.prototype.clone = function () {
			 return new Point(this.x, this.y);
		 };
		 Point.prototype.length = function (length) {
			 if (typeof length == 'undefined')
				 return Math.sqrt(this.x * this.x + this.y * this.y);
			 this.normalize();
			 this.x *= length;
			 this.y *= length;
			 return this;
		 };
		 Point.prototype.normalize = function () {
			 var length = this.length();
			 this.x /= length;
			 this.y /= length;
			 return this;
		 };
		 return Point;
	 })();
	 /*
	 * Particle class
	 */
	 var Particle = (function () {
		 function Particle() {
			 this.position = new Point();
			 this.velocity = new Point();
			 this.acceleration = new Point();
			 this.age = 0;
		 }
		 Particle.prototype.initialize = function (x, y, dx, dy) {
			 this.position.x = x;
			 this.position.y = y;
			 this.velocity.x = dx;
			 this.velocity.y = dy;
			 this.acceleration.x = dx * settings.particles.effect;
			 this.acceleration.y = dy * settings.particles.effect;
			 this.age = 0;
		 };
		 Particle.prototype.update = function (deltaTime) {
			 this.position.x += this.velocity.x * deltaTime;
			 this.position.y += this.velocity.y * deltaTime;
			 this.velocity.x += this.acceleration.x * deltaTime;
			 this.velocity.y += this.acceleration.y * deltaTime;
			 this.age += deltaTime;
		 };
		 Particle.prototype.draw = function (context, image) {
			 function ease(t) {
				 return (--t) * t * t + 1;
			 }
			 var size = image.width * ease(this.age / settings.particles.duration);
			 context.globalAlpha = 1 - this.age / settings.particles.duration;
			 context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);
		 };
		 return Particle;
	 })();
	 /*
	 * ParticlePool class
	 */
	 var ParticlePool = (function () {
		 var particles,
			 firstActive = 0,
			 firstFree = 0,
			 duration = settings.particles.duration;
		 function ParticlePool(length) {
			 // create and populate particle pool
			 particles = new Array(length);
			 for (var i = 0; i < particles.length; i++)
				 particles[i] = new Particle();
		 }
		 ParticlePool.prototype.add = function (x, y, dx, dy) {
			 particles[firstFree].initialize(x, y, dx, dy);
			 // handle circular queue
			 firstFree++;
			 if (firstFree == particles.length) firstFree = 0;
			 if (firstActive == firstFree) firstActive++;
			 if (firstActive == particles.length) firstActive = 0;
		 };
		 ParticlePool.prototype.update = function (deltaTime) {
			 var i;
			 // update active particles
			 if (firstActive < firstFree) {
				 for (i = firstActive; i < firstFree; i++)
					 particles[i].update(deltaTime);
			 }
			 if (firstFree < firstActive) {
				 for (i = firstActive; i < particles.length; i++)
					 particles[i].update(deltaTime);
				 for (i = 0; i < firstFree; i++)
					 particles[i].update(deltaTime);
			 }
			 // remove inactive particles
			 while (particles[firstActive].age >= duration && firstActive != firstFree) {
				 firstActive++;
				 if (firstActive == particles.length) firstActive = 0;
			 }
		 };
		 ParticlePool.prototype.draw = function (context, image) {
			 // draw active particles
			 if (firstActive < firstFree) {
				 for (i = firstActive; i < firstFree; i++)
					 particles[i].draw(context, image);
			 }
			 if (firstFree < firstActive) {
				 for (i = firstActive; i < particles.length; i++)
					 particles[i].draw(context, image);
				 for (i = 0; i < firstFree; i++)
					 particles[i].draw(context, image);
			 }
		 };
		 return ParticlePool;
	 })();
	 /*
	 * Putting it all together
	 */
	 (function (canvas) {
		 var context = canvas.getContext('2d'),
			 particles = new ParticlePool(settings.particles.length),
			 particleRate = settings.particles.length / settings.particles.duration, // particles/sec
			 time;
		 // get point on heart with -PI <= t <= PI
		 function pointOnHeart(t) {
			 return new Point(
				 160 * Math.pow(Math.sin(t), 3),
				 130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
			 );
		 }
		 // creating the particle image using a dummy canvas
		 var image = (function () {
			 var canvas = document.createElement('canvas'),
				 context = canvas.getContext('2d');
			 canvas.width = settings.particles.size;
			 canvas.height = settings.particles.size;
			 // helper function to create the path
			 function to(t) {
				 var point = pointOnHeart(t);
				 point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;
				 point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;
				 return point;
			 }
			 // create the path
			 context.beginPath();
			 var t = -Math.PI;
			 var point = to(t);
			 context.moveTo(point.x, point.y);
			 while (t < Math.PI) {
				 t += 0.01; // baby steps!
				 point = to(t);
				 context.lineTo(point.x, point.y);
			 }
			 context.closePath();
			 // create the fill
			 context.fillStyle = '#aaffff';
			 context.fill();
			 // create the image
			 var image = new Image();
			 image.src = canvas.toDataURL();
			 return image;
		 })();
		 // render that thing!
		 function render() {
			 // next animation frame
			 requestAnimationFrame(render);
			 // update time
			 var newTime = new Date().getTime() / 1000,
				 deltaTime = newTime - (time || newTime);
			 time = newTime;
			 // clear canvas
			 context.clearRect(0, 0, canvas.width, canvas.height);
			 // create new particles
			 var amount = particleRate * deltaTime;
			 for (var i = 0; i < amount; i++) {
				 var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
				 var dir = pos.clone().length(settings.particles.velocity);
				 particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
			 }
			 // update and draw particles
			 particles.update(deltaTime);
			 particles.draw(context, image);
		 }
		 // handle (re-)sizing of the canvas
		 function onResize() {
			 canvas.width = canvas.clientWidth;
			 canvas.height = canvas.clientHeight;
		 }
		 window.onresize = onResize;
		 // delay rendering bootstrap
		 setTimeout(function () {
			 onResize();
			 render();
		 }, 10);
	 })(document.getElementById('pinkboard'));
</script>
</div>
</body>
</html>
